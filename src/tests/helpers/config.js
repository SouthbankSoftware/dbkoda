/**
 * @Author: guiguan
 * @Date:   2017-04-13T12:34:51+10:00
 * @Last modified by:   guiguan
 * @Last modified time: 2017-06-24T00:02:51+10:00
 */

import initStateStore from './initStateStore';

/**
 * Config test suite
 *
 * @param {Object} [options={}] - config options
 * @param {boolean} [initStateStore=true] - whether to init state store
 * @param {boolean} [setupFailFastTest=true] - whether to setup fail fast test
 */
export default (options) => {
  const {
    initStateStore: _initStateStore = true,
    setupFailFastTest: _setupFailFastTest = true
  } = options || {};

  // timeout for each test case
  global.jasmine.DEFAULT_TIMEOUT_INTERVAL = process.env.DEBUG ? 7200000 : 31000;

  _initStateStore && initStateStore();
  _setupFailFastTest && setupFailFastTest();

  process.on('uncaughtException', console.error);
};

export const DELAY_TIMEOUT = 30000;
export const TEST_TEMPLATE = 'src/tests/helpers/json_template.json';

export function setupFailFastTest() {
  const oldTest = global.test;

  /** Fail-fast test */
  const test = (() => {
    let _test;

    const _wrappedFn = async (fn) => {
      if (!_test.error) {
        return fn().catch((e) => {
          // we print error here because those errors generated by `expect` do not have stacktrace
          // which won't get printed correctly by jest runner
          if (e.stack !== 'Error') {
            console.error(e.stack);
          } else {
            console.error(e);
          }
          _test.error = new Error('Previous test case has failed');
          return Promise.reject(new Error('Test case failed'));
        });
      }
      throw _test.error;
    };

    _test = (name, fn) => oldTest(name, _wrappedFn.bind(undefined, fn));
    _test.skip = (name, fn) =>
      oldTest.skip(name, _wrappedFn.bind(undefined, fn));
    _test.only = (name, fn) =>
      oldTest.only(name, _wrappedFn.bind(undefined, fn));

    _test.error = null;

    return _test;
  })();

  global.test = test;
}
